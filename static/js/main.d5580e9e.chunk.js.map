{"version":3,"sources":["index.js"],"names":["create2DArrayOf","height","width","val","newArr","length","rowI","newRow","fill","Cell","_this","this","react__WEBPACK_IMPORTED_MODULE_5___default","a","createElement","className","props","alive","onMouseOver","columnI","onMouseDown","React","PureComponent","Grid","onMouseOverCell","mouseDown","_this2","onCellToggle","_this3","cells","map","row","key","toString","cellVal","concat","Component","Game","_this4","Object","_mnt_q_Git_react_life_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__","_mnt_q_Git_react_life_node_modules_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__","_mnt_q_Git_react_life_node_modules_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__","call","pause","clearInterval","timer","setState","paused","unpause","setInterval","step","state","frequency","handleSpeedChange","event","newFrequency","target","value","toggleCell","updateCells","currStateCells","nextStateCells","gridHeight","gridWidth","generationNum","_nextStateCells","pauseUnpauseButton","onClick","type","min","max","onChange","cellsArray","translatedColumnI","cellIsAliveFunction","numNeighbors","updater","_this5","newCells","_this6","forEach","currCellAlive","cellGetNumNeighbors","cellIsAliveToroidal","document","onmousedown","onmouseup","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.d5580e9e.chunk.js","sourcesContent":["import React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\nimport \"./index.css\";\r\n\r\nfunction create2DArrayOf(height, width, val) {\r\n  let newArr = [];\r\n  newArr.length = height;\r\n  for (let rowI = 0; rowI < height; rowI++) {\r\n    let newRow = []; newRow.length = width;\r\n    newRow.fill(val, 0, newRow.length);\r\n    newArr[rowI] = newRow;\r\n  }\r\n  return newArr;\r\n}\r\n\r\nclass Cell extends React.PureComponent {\r\n  render() {\r\n    return (\r\n      <td className={\"cell \" + (this.props.alive ? \"alive\" : \"dead\")}\r\n        onMouseOver={() => this.props.onMouseOver(this.props.rowI, this.props.columnI)}\r\n        onMouseDown={() => this.props.onMouseDown(this.props.rowI, this.props.columnI)}\r\n      />\r\n    );\r\n  }\r\n}\r\n\r\nclass Grid extends React.Component {\r\n  /* This is just a grid representation component.\r\n  The source of truth is located in `Game` component. */\r\n  render() {\r\n    return (\r\n      <table className=\"grid\">\r\n        <tbody>\r\n          {this.props.cells.map((row, rowI) => (\r\n            <tr key={rowI.toString()}>\r\n              {row.map((cellVal, columnI) => (\r\n                <Cell\r\n                  rowI={rowI}\r\n                  columnI={columnI}\r\n                  alive={cellVal}\r\n                  key={`${rowI}:${columnI}`}\r\n                  onMouseOver={this.onMouseOverCell}\r\n                  onMouseDown={this.props.onCellToggle}\r\n                />\r\n              ))}\r\n            </tr>\r\n          ))}\r\n        </tbody>\r\n      </table>\r\n    );\r\n  }\r\n\r\n  onMouseOverCell = (rowI, columnI) => {\r\n    if (mouseDown) {\r\n      this.props.onCellToggle(rowI, columnI);\r\n    }\r\n  }\r\n}\r\n\r\nclass Game extends React.Component {\r\n  // TODO implement using Redux?\r\n  constructor (props) {\r\n    super(props);\r\n    // Grid generation\r\n    this.gridHeight = 41;\r\n    this.gridWidth = 37;\r\n    let cells = create2DArrayOf(this.gridHeight, this.gridWidth, false);\r\n    this.state = {\r\n      // TODO replace with 1D?\r\n      cells: cells, // A 2D array of bool.\r\n      frequency: \"frequency\" in props ? props.frequency : 4,  // In seconds\r\n      paused: true,\r\n      generationNum: 0\r\n    };\r\n    this._nextStateCells = create2DArrayOf(this.gridHeight, this.gridWidth, false);\r\n  }\r\n\r\n  render() {\r\n    let pauseUnpauseButton;\r\n    if (this.state.paused) {\r\n      pauseUnpauseButton = <button onClick={this.unpause}>Unpause</button>;\r\n    } else {\r\n      pauseUnpauseButton = <button onClick={this.pause}>Pause</button>;\r\n    }\r\n    return (\r\n      <div>\r\n        <div className=\"control-panel\">\r\n          {pauseUnpauseButton}\r\n          <input type=\"range\" min=\"0.5\" max=\"60\"\r\n            value={this.state.frequency}\r\n            onChange={this.handleSpeedChange}\r\n          />\r\n          <span>{this.state.generationNum}</span>\r\n        </div>\r\n        <Grid\r\n          cells={this.state.cells}\r\n          onCellToggle={this.toggleCell}\r\n        />\r\n      </div>\r\n    );\r\n  }\r\n\r\n  pause = () => {\r\n    clearInterval(this.timer);\r\n    this.setState({ paused: true });\r\n  }\r\n\r\n  unpause = () => {\r\n    this.timer = setInterval(() => this.step(), 1 / this.state.frequency * 1000);\r\n    this.setState({ paused: false });\r\n  }\r\n\r\n  handleSpeedChange = (event) => {\r\n    const newFrequency = event.target.value;\r\n    if (!this.state.paused) {\r\n      clearInterval(this.timer);\r\n      this.timer = setInterval(() => this.step(), 1 / newFrequency * 1000);\r\n    }\r\n    this.setState({ frequency: newFrequency });\r\n  }\r\n\r\n  cellIsAlive(cellsArray, rowI, columnI) {\r\n    const height = cellsArray.length;\r\n    const width = cellsArray[0].length;\r\n    if (rowI < 0 || rowI >= height ||\r\n      columnI < 0 || columnI >= width) {\r\n      return false;\r\n    }\r\n    if (cellsArray[rowI][columnI] === false) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  cellIsAliveToroidal(cellsArray, rowI, columnI) {\r\n    const height = cellsArray.length;\r\n    const width = cellsArray[0].length;\r\n    let translatedRowI, translatedColumnI;\r\n    if (rowI === -1) {\r\n      translatedRowI = height - 1;\r\n    } else if (rowI === height) {\r\n      translatedRowI = 0;\r\n    } else {\r\n      translatedRowI = rowI;\r\n    }\r\n    if (columnI === -1) {\r\n      translatedColumnI = width - 1;\r\n    } else if (columnI === width) {\r\n      translatedColumnI = 0;\r\n    } else {\r\n      translatedColumnI = columnI;\r\n    }\r\n    return cellsArray[translatedRowI][translatedColumnI];\r\n  }\r\n\r\n  cellGetNumNeighbors(cellsArray, rowI, columnI, cellIsAliveFunction) { \r\n    let numNeighbors = 0;\r\n    if (cellIsAliveFunction(cellsArray, rowI - 1, columnI - 1)) numNeighbors++;\r\n    if (cellIsAliveFunction(cellsArray, rowI - 1, columnI)) numNeighbors++;\r\n    if (cellIsAliveFunction(cellsArray, rowI - 1, columnI + 1)) numNeighbors++;\r\n    if (cellIsAliveFunction(cellsArray, rowI, columnI - 1)) numNeighbors++;\r\n    if (cellIsAliveFunction(cellsArray, rowI, columnI + 1)) numNeighbors++;\r\n    if (cellIsAliveFunction(cellsArray, rowI + 1, columnI - 1)) numNeighbors++;\r\n    if (cellIsAliveFunction(cellsArray, rowI + 1, columnI)) numNeighbors++;\r\n    if (cellIsAliveFunction(cellsArray, rowI + 1, columnI + 1)) numNeighbors++;\r\n    return numNeighbors;\r\n  }\r\n\r\n  updateCells(updater) {\r\n    /* If an update needs to be done to cells, this function must be called.\r\n    `updater` must be a function like:\r\n    `(currStateCells, nextStateCells) => { ... }`, which defines the way the\r\n    cells must be updated. currStateCells must not be modified.\r\n    `nextStateCells` will be assigned to the current state upon execution. */\r\n    this.setState((state, props) => {\r\n      // Copy the current state.\r\n      const height = state.cells.length, width = state.cells[0].length;\r\n      for (let rowI = 0; rowI < height; rowI++) {\r\n        for (let columnI = 0; columnI < width; columnI++) {\r\n          this._nextStateCells[rowI][columnI] = state.cells[rowI][columnI];\r\n        }\r\n      }\r\n      updater(state.cells, this._nextStateCells);\r\n\r\n      // The array pointed to by `this._nextStateCells` becomes a new state\r\n      // The array pointed to by `state.cells` is new considered to\r\n      // contain waste and is assigned to this._nextStateCells for further\r\n      // rewriting to avoid memory reallocation.\r\n      const newCells = this._nextStateCells;\r\n      this._nextStateCells = state.cells;\r\n      return { cells: newCells };\r\n    });\r\n  }\r\n\r\n  step () {\r\n    /* TODO calculate the next step before the time has passed?\r\n    Recalculate if the user drew something.*/\r\n    // TODO only calcualte cells whose neighbours have changed.\r\n    this.updateCells((currStateCells, nextStateCells) => {\r\n      currStateCells.forEach((row, rowI) => {\r\n        row.forEach((currCellAlive, columnI) => {\r\n          // Now, the actual game logic\r\n          let numNeighbors = this.cellGetNumNeighbors(\r\n            currStateCells,\r\n            rowI,\r\n            columnI,\r\n            this.cellIsAliveToroidal);\r\n          if (\r\n            numNeighbors === 3 ||\r\n            (numNeighbors === 2 && currCellAlive)\r\n          ) {\r\n            nextStateCells[rowI][columnI] = true;\r\n          } else {\r\n            nextStateCells[rowI][columnI] = false;\r\n          }\r\n        });\r\n      });\r\n    });\r\n    this.setState((state, props) => ({generationNum: state.generationNum + 1}));\r\n  }\r\n\r\n  toggleCell = (rowI, columnI) => {\r\n    this.updateCells((currStateCells, nextStateCells) => {\r\n      nextStateCells[rowI][columnI] = !currStateCells[rowI][columnI];\r\n    });\r\n  }\r\n}\r\n\r\nvar mouseDown = false;\r\ndocument.onmousedown = function() {\r\n  mouseDown = true;\r\n};\r\ndocument.onmouseup = function () {\r\n  mouseDown = false;\r\n};\r\n\r\nReactDOM.render(\r\n  <Game />,\r\n  document.getElementById(\"root\")\r\n);\r\n"],"sourceRoot":""}
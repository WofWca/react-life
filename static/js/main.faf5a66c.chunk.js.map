{"version":3,"sources":["index.js"],"names":["create2DArrayOf","height","width","val","newArr","length","rowI","newRow","fill","Cell","_this","this","react__WEBPACK_IMPORTED_MODULE_5___default","a","createElement","className","onMouseOver","props","columnI","onMouseDown","style","backgroundColor","alive","border","React","PureComponent","Grid","onMouseOverCell","mouseDown","_this2","onCellToggle","_this3","borderCollapse","cells","map","row","key","toString","cellVal","concat","Component","Game","_this4","Object","_mnt_q_Git_react_life_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__","_mnt_q_Git_react_life_node_modules_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__","_mnt_q_Git_react_life_node_modules_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__","call","pause","clearInterval","timer","setState","paused","unpause","setInterval","step","state","frequency","handleSpeedChange","event","newFrequency","target","value","toggleCell","updateCells","currStateCells","nextStateCells","gridHeight","gridWidth","generationNum","_nextStateCells","pauseUnpauseButton","onClick","type","min","max","onChange","cellsArray","translatedColumnI","cellIsAliveFunction","numNeighbors","updater","_this5","newCells","_this6","forEach","currCellAlive","cellGetNumNeighbors","cellIsAliveToroidal","document","onmousedown","onmouseup","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.faf5a66c.chunk.js","sourcesContent":["import React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\n\r\nfunction create2DArrayOf(height, width, val) {\r\n  let newArr = [];\r\n  newArr.length = height;\r\n  for (let rowI = 0; rowI < height; rowI++) {\r\n    let newRow = []; newRow.length = width;\r\n    newRow.fill(val, 0, newRow.length);\r\n    newArr[rowI] = newRow;\r\n  }\r\n  return newArr;\r\n}\r\n\r\nclass Cell extends React.PureComponent {\r\n  render() {\r\n    return (\r\n      <td className=\"square\"\r\n        onMouseOver={() => this.props.onMouseOver(this.props.rowI, this.props.columnI)}\r\n        onMouseDown={() => this.props.onMouseDown(this.props.rowI, this.props.columnI)}\r\n        style={{\r\n          backgroundColor: (this.props.alive ? \"black\" : \"white\"),\r\n          // TODO define sizes somewhere else?\r\n          width: \"10px\",\r\n          height: \"10px\",\r\n          border: \"solid gray 1px\"\r\n        }}\r\n      />\r\n    );\r\n  }\r\n}\r\n\r\nclass Grid extends React.Component {\r\n  /* This is just a grid representation component.\r\n  The source of truth is located in `Game` component. */\r\n  render() {\r\n    return (\r\n      <table style={{borderCollapse: \"collapse\"}}>\r\n        <tbody>\r\n          {this.props.cells.map((row, rowI) => (\r\n            <tr className=\"gridRow\" key={rowI.toString()}>\r\n              {row.map((cellVal, columnI) => (\r\n                <Cell\r\n                  rowI={rowI}\r\n                  columnI={columnI}\r\n                  alive={cellVal}\r\n                  key={`${rowI}:${columnI}`}\r\n                  onMouseOver={this.onMouseOverCell}\r\n                  onMouseDown={this.props.onCellToggle}\r\n                />\r\n              ))}\r\n            </tr>\r\n          ))}\r\n        </tbody>\r\n      </table>\r\n    );\r\n  }\r\n\r\n  onMouseOverCell = (rowI, columnI) => {\r\n    if (mouseDown) {\r\n      this.props.onCellToggle(rowI, columnI);\r\n    }\r\n  }\r\n}\r\n\r\nclass Game extends React.Component {\r\n  // TODO implement using Redux?\r\n  constructor (props) {\r\n    super(props);\r\n    // Grid generation\r\n    this.gridHeight = 40;\r\n    this.gridWidth = 35;\r\n    let cells = create2DArrayOf(this.gridHeight, this.gridWidth, false);\r\n    this.state = {\r\n      // TODO replace with 1D?\r\n      cells: cells, // A 2D array of bool.\r\n      frequency: \"frequency\" in props ? props.frequency : 4,  // In seconds\r\n      paused: true,\r\n      generationNum: 0\r\n    };\r\n    this._nextStateCells = create2DArrayOf(this.gridHeight, this.gridWidth, false);\r\n  }\r\n\r\n  render() {\r\n    let pauseUnpauseButton;\r\n    if (this.state.paused) {\r\n      pauseUnpauseButton = <button onClick={this.unpause}>Unpause</button>;\r\n    } else {\r\n      pauseUnpauseButton = <button onClick={this.pause}>Pause</button>;\r\n    }\r\n    return (\r\n      <div>\r\n        <div className=\"control-panel\">\r\n          {pauseUnpauseButton}\r\n          <input type=\"range\" min=\"0.5\" max=\"60\"\r\n            value={this.state.frequency}\r\n            onChange={this.handleSpeedChange}\r\n          />\r\n          <span>{this.state.generationNum}</span>\r\n        </div>\r\n        <Grid\r\n          cells={this.state.cells}\r\n          onCellToggle={this.toggleCell}\r\n        />\r\n      </div>\r\n    );\r\n  }\r\n\r\n  pause = () => {\r\n    clearInterval(this.timer);\r\n    this.setState({ paused: true });\r\n  }\r\n\r\n  unpause = () => {\r\n    this.timer = setInterval(() => this.step(), 1 / this.state.frequency * 1000);\r\n    this.setState({ paused: false });\r\n  }\r\n\r\n  handleSpeedChange = (event) => {\r\n    const newFrequency = event.target.value;\r\n    if (!this.state.paused) {\r\n      clearInterval(this.timer);\r\n      this.timer = setInterval(() => this.step(), 1 / newFrequency * 1000);\r\n    }\r\n    this.setState({ frequency: newFrequency });\r\n  }\r\n\r\n  cellIsAlive(cellsArray, rowI, columnI) {\r\n    const height = cellsArray.length;\r\n    const width = cellsArray[0].length;\r\n    if (rowI < 0 || rowI >= height ||\r\n      columnI < 0 || columnI >= width) {\r\n      return false;\r\n    }\r\n    if (cellsArray[rowI][columnI] === false) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  cellIsAliveToroidal(cellsArray, rowI, columnI) {\r\n    const height = cellsArray.length;\r\n    const width = cellsArray[0].length;\r\n    let translatedRowI, translatedColumnI;\r\n    if (rowI === -1) {\r\n      translatedRowI = height - 1;\r\n    } else if (rowI === height) {\r\n      translatedRowI = 0;\r\n    } else {\r\n      translatedRowI = rowI;\r\n    }\r\n    if (columnI === -1) {\r\n      translatedColumnI = width - 1;\r\n    } else if (columnI === width) {\r\n      translatedColumnI = 0;\r\n    } else {\r\n      translatedColumnI = columnI;\r\n    }\r\n    return cellsArray[translatedRowI][translatedColumnI];\r\n  }\r\n\r\n  cellGetNumNeighbors(cellsArray, rowI, columnI, cellIsAliveFunction) { \r\n    let numNeighbors = 0;\r\n    if (cellIsAliveFunction(cellsArray, rowI - 1, columnI - 1)) numNeighbors++;\r\n    if (cellIsAliveFunction(cellsArray, rowI - 1, columnI)) numNeighbors++;\r\n    if (cellIsAliveFunction(cellsArray, rowI - 1, columnI + 1)) numNeighbors++;\r\n    if (cellIsAliveFunction(cellsArray, rowI, columnI - 1)) numNeighbors++;\r\n    if (cellIsAliveFunction(cellsArray, rowI, columnI + 1)) numNeighbors++;\r\n    if (cellIsAliveFunction(cellsArray, rowI + 1, columnI - 1)) numNeighbors++;\r\n    if (cellIsAliveFunction(cellsArray, rowI + 1, columnI)) numNeighbors++;\r\n    if (cellIsAliveFunction(cellsArray, rowI + 1, columnI + 1)) numNeighbors++;\r\n    return numNeighbors;\r\n  }\r\n\r\n  updateCells(updater) {\r\n    /* If an update needs to be done to cells, this function must be called.\r\n    `updater` must be a function like:\r\n    `(currStateCells, nextStateCells) => { ... }`, which defines the way the\r\n    cells must be updated. currStateCells must not be modified.\r\n    `nextStateCells` will be assigned to the current state upon execution. */\r\n    this.setState((state, props) => {\r\n      // Copy the current state.\r\n      const height = state.cells.length, width = state.cells[0].length;\r\n      for (let rowI = 0; rowI < height; rowI++) {\r\n        for (let columnI = 0; columnI < width; columnI++) {\r\n          this._nextStateCells[rowI][columnI] = state.cells[rowI][columnI];\r\n        }\r\n      }\r\n      updater(state.cells, this._nextStateCells);\r\n\r\n      // The array pointed to by `this._nextStateCells` becomes a new state\r\n      // The array pointed to by `state.cells` is new considered to\r\n      // contain waste and is assigned to this._nextStateCells for further\r\n      // rewriting to avoid memory reallocation.\r\n      const newCells = this._nextStateCells;\r\n      this._nextStateCells = state.cells;\r\n      return { cells: newCells };\r\n    });\r\n  }\r\n\r\n  step () {\r\n    /* TODO calculate the next step before the time has passed?\r\n    Recalculate if the user drew something.*/\r\n    // TODO only calcualte cells whose neighbours have changed.\r\n    this.updateCells((currStateCells, nextStateCells) => {\r\n      currStateCells.forEach((row, rowI) => {\r\n        row.forEach((currCellAlive, columnI) => {\r\n          // Now, the actual game logic\r\n          let numNeighbors = this.cellGetNumNeighbors(\r\n            currStateCells,\r\n            rowI,\r\n            columnI,\r\n            this.cellIsAliveToroidal);\r\n          if (\r\n            numNeighbors === 3 ||\r\n            (numNeighbors === 2 && currCellAlive)\r\n          ) {\r\n            nextStateCells[rowI][columnI] = true;\r\n          } else {\r\n            nextStateCells[rowI][columnI] = false;\r\n          }\r\n        });\r\n      });\r\n    });\r\n    this.setState((state, props) => ({generationNum: state.generationNum + 1}));\r\n  }\r\n\r\n  toggleCell = (rowI, columnI) => {\r\n    this.updateCells((currStateCells, nextStateCells) => {\r\n      nextStateCells[rowI][columnI] = !currStateCells[rowI][columnI];\r\n    });\r\n  }\r\n}\r\n\r\nvar mouseDown = false;\r\ndocument.onmousedown = function() {\r\n  mouseDown = true;\r\n};\r\ndocument.onmouseup = function () {\r\n  mouseDown = false;\r\n};\r\n\r\nReactDOM.render(\r\n  <Game />,\r\n  document.getElementById(\"root\")\r\n);\r\n"],"sourceRoot":""}
{"version":3,"sources":["index.js"],"names":["Cell","_this","this","react__WEBPACK_IMPORTED_MODULE_5___default","a","createElement","className","onMouseOver","props","rowI","columnI","onMouseDown","style","backgroundColor","alive","width","height","border","React","Component","Grid","onMouseOverCell","_this2","mouseOverCell","mouseDown","onCellToggle","_this3","borderCollapse","cells","map","row","key","toString","cellVal","concat","Game","_this4","Object","_mnt_q_Git_react_test_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__","_mnt_q_Git_react_test_node_modules_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__","_mnt_q_Git_react_test_node_modules_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__","call","toggleCell","newCells","state","setState","generationNum","frequency","gridHeight","length","gridWidth","nextGenCells","newRow","fill","numNeighbors","cellIsAlive","_this5","slice","forEach","currCellAlive","cellGetNumNeighbors","coldCellsGenArr","_this6","timer","setInterval","step","document","onmousedown","onmouseup","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.962c8579.chunk.js","sourcesContent":["import React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\n\r\nclass Cell extends React.Component {\r\n  render() {\r\n    return (\r\n      <td className=\"square\"\r\n        onMouseOver={() => this.props.onMouseOver(this.props.rowI, this.props.columnI)}\r\n        onMouseDown={() => this.props.onMouseDown(this.props.rowI, this.props.columnI)}\r\n        style={{\r\n          backgroundColor: (this.props.alive ? \"black\" : \"white\"),\r\n          // TODO define sizes somewhere else?\r\n          width: \"10px\",\r\n          height: \"10px\",\r\n          border: \"solid gray 1px\"\r\n        }}\r\n      />\r\n    );\r\n  }\r\n}\r\n\r\nclass Grid extends React.Component {\r\n  /* This is just a grid representation component.\r\n  The source of truth is located in `Game` component. */\r\n  render() {\r\n    return (\r\n      <table style={{borderCollapse: \"collapse\"}}>\r\n        <tbody>\r\n          {this.props.cells.map((row, rowI) => (\r\n            <tr className=\"gridRow\" key={rowI.toString()}>\r\n              {row.map((cellVal, columnI) => (\r\n                <Cell\r\n                  rowI={rowI}\r\n                  columnI={columnI}\r\n                  alive={cellVal}\r\n                  key={`${rowI}:${columnI}`}\r\n                  onMouseOver={this.onMouseOverCell}\r\n                  onMouseDown={this.props.onCellToggle}\r\n                />\r\n              ))}\r\n            </tr>\r\n          ))}\r\n        </tbody>\r\n      </table>\r\n    );\r\n  }\r\n\r\n  onMouseOverCell = (rowI, columnI) => {\r\n    this.mouseOverCell = { rowI, columnI };\r\n    if (mouseDown) {\r\n      this.props.onCellToggle(rowI, columnI);\r\n    }\r\n  }\r\n}\r\n\r\nclass Game extends React.Component {\r\n  // TODO implement using Redux?\r\n  constructor (props) {\r\n    super(props);\r\n    this.state = {\r\n      // TODO replace with 1D?\r\n      cells: props.cells, // A 2D array of bool.\r\n    };\r\n    this.generationNum = 0;\r\n    this.frequency = \"frequency\" in props ? props.frequency : 2;  // In seconds\r\n    this.gridHeight = props.cells.length;\r\n    this.gridWidth = props.cells[0].length;\r\n    this.nextGenCells = [];\r\n    this.nextGenCells.length = this.gridHeight;\r\n    for (let rowI = 0; rowI < this.nextGenCells.length; rowI++) {\r\n      let newRow = []; newRow.length = this.gridWidth;\r\n      newRow.fill(false, 0, newRow.length);\r\n      this.nextGenCells[rowI] = newRow;\r\n    }\r\n  }\r\n\r\n  cellIsAlive(rowI, columnI) {\r\n    if (rowI < 0 || rowI >= this.gridHeight ||\r\n      columnI < 0 || columnI >= this.gridWidth) {\r\n      return false;\r\n    }\r\n    if (this.state.cells[rowI][columnI] === false) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  cellGetNumNeighbors (rowI, columnI) { \r\n    let numNeighbors = 0;\r\n    if (this.cellIsAlive(rowI - 1, columnI - 1)) numNeighbors++;\r\n    if (this.cellIsAlive(rowI - 1, columnI)) numNeighbors++;\r\n    if (this.cellIsAlive(rowI - 1, columnI + 1)) numNeighbors++;\r\n    if (this.cellIsAlive(rowI, columnI - 1)) numNeighbors++;\r\n    if (this.cellIsAlive(rowI, columnI + 1)) numNeighbors++;\r\n    if (this.cellIsAlive(rowI + 1, columnI - 1)) numNeighbors++;\r\n    if (this.cellIsAlive(rowI + 1, columnI)) numNeighbors++;\r\n    if (this.cellIsAlive(rowI + 1, columnI + 1)) numNeighbors++;\r\n    return numNeighbors;\r\n  }\r\n\r\n  step () {\r\n    // TODO calculate the next step before the time has passed\r\n    // TODO only calcualte cells whose neighbours have changed.\r\n\r\n    // Copy the from the old state.\r\n    // You can't just `this.nextGenCells = this.state.cells.slice()`, as this is\r\n    // a shallow copy.\r\n    for (let rowI = 0; rowI < this.nextGenCells.length; rowI++) {\r\n      this.nextGenCells[rowI] = this.state.cells[rowI].slice();\r\n    }\r\n\r\n    // TODO these forEach(..., this) are ugly.\r\n    this.state.cells.forEach((row, rowI) => {\r\n      row.forEach((currCellAlive, columnI) => {\r\n        // Now, the actual game logic\r\n        let numNeighbors = this.cellGetNumNeighbors(rowI, columnI);\r\n        if (\r\n          numNeighbors === 3 ||\r\n          (numNeighbors === 2 && currCellAlive)\r\n        ) {\r\n          this.nextGenCells[rowI][columnI] = true;\r\n        } else {\r\n          this.nextGenCells[rowI][columnI] = false;\r\n        }\r\n      }, this);\r\n    }, this);\r\n    // Exchange the current state and the buffer for the next one.\r\n    let coldCellsGenArr = this.state.cells;\r\n    this.setState({ cells: this.nextGenCells });\r\n    this.nextGenCells = coldCellsGenArr;\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <Grid\r\n        cells={this.state.cells}\r\n        onCellToggle={this.toggleCell}\r\n      />\r\n    );\r\n  }\r\n\r\n  toggleCell = (rowI, columnI) => {\r\n    let newCells = this.state.cells;\r\n    newCells[rowI][columnI] = !newCells[rowI][columnI];\r\n    this.setState({cells: newCells});\r\n  }\r\n\r\n  componentDidMount() {\r\n    this.timer = setInterval(() => this.step(), 1 / this.frequency * 1000);\r\n  }\r\n}\r\n\r\nvar mouseDown = false;\r\ndocument.onmousedown = function() {\r\n  mouseDown = true;\r\n};\r\ndocument.onmouseup = function () {\r\n  mouseDown = false;\r\n};\r\n\r\nlet cells = [\r\n  [false, true, false, false, false, true, false],\r\n  [false, false, true, false, false, true, false],\r\n  [true, true, true, false, false, true, false],\r\n  [false, false, false, false, false, false, false],\r\n  [false, false, false, false, false, false, false],\r\n  [false, false, false, false, false, false, false],\r\n];\r\nReactDOM.render(\r\n  <Game cells={cells}/>,\r\n  document.getElementById(\"root\")\r\n);"],"sourceRoot":""}
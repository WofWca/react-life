{"version":3,"sources":["index.js"],"names":["create2DArrayOf","height","width","val","newArr","length","rowI","newRow","fill","Cell","_this","this","react__WEBPACK_IMPORTED_MODULE_6___default","a","createElement","className","onMouseOver","props","columnI","onMouseDown","style","backgroundColor","alive","border","React","Component","Grid","_this2","Object","_mnt_q_Git_react_life_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_1__","_mnt_q_Git_react_life_node_modules_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__","_mnt_q_Git_react_life_node_modules_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__","call","onMouseOverCell","mouseOverCell","mouseDown","onCellToggle","undefined","_this3","borderCollapse","cells","map","row","key","toString","cellVal","concat","Game","_this4","togglePaused","newPaused","state","paused","timer","setInterval","step","frequency","clearInterval","setState","_mnt_q_Git_react_life_node_modules_babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_0__","handleSpeedChange","event","target","value","toggleCell","newCells","gridHeight","gridDimensions","gridWidth","generationNum","nextGenCells","onClick","type","min","max","onChange","numNeighbors","cellIsAlive","_this5","slice","forEach","currCellAlive","cellGetNumNeighbors","coldCellsGenArr","document","onmousedown","onmouseup","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.f2364a04.chunk.js","sourcesContent":["import React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\n\r\nfunction create2DArrayOf(height, width, val) {\r\n  let newArr = [];\r\n  newArr.length = height;\r\n  for (let rowI = 0; rowI < height; rowI++) {\r\n    let newRow = []; newRow.length = width;\r\n    newRow.fill(val, 0, newRow.length);\r\n    newArr[rowI] = newRow;\r\n  }\r\n  return newArr;\r\n}\r\n\r\nclass Cell extends React.Component {\r\n  render() {\r\n    return (\r\n      <td className=\"square\"\r\n        onMouseOver={() => this.props.onMouseOver(this.props.rowI, this.props.columnI)}\r\n        onMouseDown={() => this.props.onMouseDown(this.props.rowI, this.props.columnI)}\r\n        style={{\r\n          backgroundColor: (this.props.alive ? \"black\" : \"white\"),\r\n          // TODO define sizes somewhere else?\r\n          width: \"10px\",\r\n          height: \"10px\",\r\n          border: \"solid gray 1px\"\r\n        }}\r\n      />\r\n    );\r\n  }\r\n}\r\n\r\nclass Grid extends React.Component {\r\n  /* This is just a grid representation component.\r\n  The source of truth is located in `Game` component. */\r\n  constructor (props) {\r\n    super(props);\r\n    this.mouseOverCell = { rowI: undefined, columnI: undefined };\r\n  }\r\n  render() {\r\n    return (\r\n      <table style={{borderCollapse: \"collapse\"}}>\r\n        <tbody>\r\n          {this.props.cells.map((row, rowI) => (\r\n            <tr className=\"gridRow\" key={rowI.toString()}>\r\n              {row.map((cellVal, columnI) => (\r\n                <Cell\r\n                  rowI={rowI}\r\n                  columnI={columnI}\r\n                  alive={cellVal}\r\n                  key={`${rowI}:${columnI}`}\r\n                  onMouseOver={this.onMouseOverCell}\r\n                  onMouseDown={this.props.onCellToggle}\r\n                />\r\n              ))}\r\n            </tr>\r\n          ))}\r\n        </tbody>\r\n      </table>\r\n    );\r\n  }\r\n\r\n  onMouseOverCell = (rowI, columnI) => {\r\n    this.mouseOverCell.rowI = rowI;\r\n    this.mouseOverCell.columnI = columnI;\r\n    if (mouseDown) {\r\n      this.props.onCellToggle(rowI, columnI);\r\n    }\r\n  }\r\n}\r\n\r\nclass Game extends React.Component {\r\n  // TODO implement using Redux?\r\n  constructor (props) {\r\n    super(props);\r\n    // Grid generation\r\n    this.gridHeight = \"gridDimensions\" in props ? props.gridDimensions.height : 20;\r\n    this.gridWidth = \"gridDimensions\" in props ? props.gridDimensions.width : 20;\r\n    let cells = create2DArrayOf(this.gridHeight, this.gridWidth, false);\r\n    this.state = {\r\n      // TODO replace with 1D?\r\n      cells: cells, // A 2D array of bool.\r\n      frequency: \"frequency\" in props ? props.frequency : 4,  // In seconds\r\n      paused: true\r\n    };\r\n\r\n    this.generationNum = 0;\r\n    this.nextGenCells = create2DArrayOf(this.gridHeight, this.gridWidth, false);\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div>\r\n        <div className=\"controls\">\r\n          <button onClick={this.togglePaused}>\r\n            {this.state.paused ? \"Unpause\" : \"Pause\"}\r\n          </button>\r\n          <input type=\"range\" min=\"0.5\" max=\"20\"\r\n            value={this.state.frequency}\r\n            onChange={this.handleSpeedChange}\r\n          />\r\n        </div>\r\n        <Grid\r\n          cells={this.state.cells}\r\n          onCellToggle={this.toggleCell}\r\n        />\r\n      </div>\r\n    );\r\n  }\r\n\r\n  togglePaused = () => {\r\n    let newPaused;\r\n    if (this.state.paused) {\r\n      this.timer = setInterval(() => this.step(), 1 / this.state.frequency * 1000);\r\n      newPaused = false;\r\n    } else {\r\n      clearInterval(this.timer);\r\n      newPaused = true;\r\n    }\r\n    this.setState({ ...this.state, paused: newPaused });\r\n  }\r\n\r\n  handleSpeedChange = (event) => {\r\n    clearInterval(this.timer);\r\n    this.timer = setInterval(() => this.step(), 1 / event.target.value * 1000);\r\n    // TODO can we maybe make this slider a separate component so we don't have\r\n    // to update the whole game every time it is changed?\r\n    this.setState({ ...this.state, frequency: event.target.value });\r\n  }\r\n\r\n  cellIsAlive(rowI, columnI) {\r\n    if (rowI < 0 || rowI >= this.gridHeight ||\r\n      columnI < 0 || columnI >= this.gridWidth) {\r\n      return false;\r\n    }\r\n    if (this.state.cells[rowI][columnI] === false) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  cellGetNumNeighbors (rowI, columnI) { \r\n    let numNeighbors = 0;\r\n    if (this.cellIsAlive(rowI - 1, columnI - 1)) numNeighbors++;\r\n    if (this.cellIsAlive(rowI - 1, columnI)) numNeighbors++;\r\n    if (this.cellIsAlive(rowI - 1, columnI + 1)) numNeighbors++;\r\n    if (this.cellIsAlive(rowI, columnI - 1)) numNeighbors++;\r\n    if (this.cellIsAlive(rowI, columnI + 1)) numNeighbors++;\r\n    if (this.cellIsAlive(rowI + 1, columnI - 1)) numNeighbors++;\r\n    if (this.cellIsAlive(rowI + 1, columnI)) numNeighbors++;\r\n    if (this.cellIsAlive(rowI + 1, columnI + 1)) numNeighbors++;\r\n    return numNeighbors;\r\n  }\r\n\r\n  step () {\r\n    // TODO calculate the next step before the time has passed\r\n    // TODO only calcualte cells whose neighbours have changed.\r\n\r\n    // Copy the from the old state.\r\n    // You can't just `this.nextGenCells = this.state.cells.slice()`, as this is\r\n    // a shallow copy.\r\n    for (let rowI = 0; rowI < this.nextGenCells.length; rowI++) {\r\n      this.nextGenCells[rowI] = this.state.cells[rowI].slice();\r\n    }\r\n\r\n    // TODO these forEach(..., this) are ugly.\r\n    this.state.cells.forEach((row, rowI) => {\r\n      row.forEach((currCellAlive, columnI) => {\r\n        // Now, the actual game logic\r\n        let numNeighbors = this.cellGetNumNeighbors(rowI, columnI);\r\n        if (\r\n          numNeighbors === 3 ||\r\n          (numNeighbors === 2 && currCellAlive)\r\n        ) {\r\n          this.nextGenCells[rowI][columnI] = true;\r\n        } else {\r\n          this.nextGenCells[rowI][columnI] = false;\r\n        }\r\n      }, this);\r\n    }, this);\r\n    // Exchange the current state and the buffer for the next one.\r\n    let coldCellsGenArr = this.state.cells;\r\n    this.setState({...this.state, cells: this.nextGenCells });\r\n    this.nextGenCells = coldCellsGenArr;\r\n  }\r\n\r\n  toggleCell = (rowI, columnI) => {\r\n    let newCells = this.state.cells;\r\n    newCells[rowI][columnI] = !newCells[rowI][columnI];\r\n    this.setState({...this.state, cells: newCells});\r\n  }\r\n}\r\n\r\nvar mouseDown = false;\r\ndocument.onmousedown = function() {\r\n  mouseDown = true;\r\n};\r\ndocument.onmouseup = function () {\r\n  mouseDown = false;\r\n};\r\n\r\nReactDOM.render(\r\n  <Game gridDimensions={{ height: 30, width: 30 }} />,\r\n  document.getElementById(\"root\")\r\n);"],"sourceRoot":""}
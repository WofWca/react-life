{"version":3,"sources":["index.js"],"names":["create2DArrayOf","height","width","val","newArr","length","rowI","newRow","fill","Cell","_this","this","react__WEBPACK_IMPORTED_MODULE_6___default","a","createElement","className","onMouseOver","props","columnI","onMouseDown","style","backgroundColor","alive","border","React","Component","Grid","onMouseOverCell","_this2","mouseOverCell","mouseDown","onCellToggle","_this3","borderCollapse","cells","map","row","key","toString","cellVal","concat","Game","_this4","Object","_mnt_q_Git_react_life_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_1__","_mnt_q_Git_react_life_node_modules_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__","_mnt_q_Git_react_life_node_modules_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__","call","togglePaused","newPaused","state","paused","timer","setInterval","step","frequency","clearInterval","setState","_mnt_q_Git_react_life_node_modules_babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_0__","toggleCell","newCells","gridHeight","gridDimensions","gridWidth","generationNum","nextGenCells","onClick","numNeighbors","cellIsAlive","_this5","slice","forEach","currCellAlive","cellGetNumNeighbors","coldCellsGenArr","document","onmousedown","onmouseup","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.36b66fac.chunk.js","sourcesContent":["import React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\n\r\nfunction create2DArrayOf(height, width, val) {\r\n  let newArr = [];\r\n  newArr.length = height;\r\n  for (let rowI = 0; rowI < height; rowI++) {\r\n    let newRow = []; newRow.length = width;\r\n    newRow.fill(val, 0, newRow.length);\r\n    newArr[rowI] = newRow;\r\n  }\r\n  return newArr;\r\n}\r\n\r\nclass Cell extends React.Component {\r\n  render() {\r\n    return (\r\n      <td className=\"square\"\r\n        onMouseOver={() => this.props.onMouseOver(this.props.rowI, this.props.columnI)}\r\n        onMouseDown={() => this.props.onMouseDown(this.props.rowI, this.props.columnI)}\r\n        style={{\r\n          backgroundColor: (this.props.alive ? \"black\" : \"white\"),\r\n          // TODO define sizes somewhere else?\r\n          width: \"10px\",\r\n          height: \"10px\",\r\n          border: \"solid gray 1px\"\r\n        }}\r\n      />\r\n    );\r\n  }\r\n}\r\n\r\nclass Grid extends React.Component {\r\n  /* This is just a grid representation component.\r\n  The source of truth is located in `Game` component. */\r\n  render() {\r\n    return (\r\n      <table style={{borderCollapse: \"collapse\"}}>\r\n        <tbody>\r\n          {this.props.cells.map((row, rowI) => (\r\n            <tr className=\"gridRow\" key={rowI.toString()}>\r\n              {row.map((cellVal, columnI) => (\r\n                <Cell\r\n                  rowI={rowI}\r\n                  columnI={columnI}\r\n                  alive={cellVal}\r\n                  key={`${rowI}:${columnI}`}\r\n                  onMouseOver={this.onMouseOverCell}\r\n                  onMouseDown={this.props.onCellToggle}\r\n                />\r\n              ))}\r\n            </tr>\r\n          ))}\r\n        </tbody>\r\n      </table>\r\n    );\r\n  }\r\n\r\n  onMouseOverCell = (rowI, columnI) => {\r\n    this.mouseOverCell = { rowI, columnI };\r\n    if (mouseDown) {\r\n      this.props.onCellToggle(rowI, columnI);\r\n    }\r\n  }\r\n}\r\n\r\nclass Game extends React.Component {\r\n  // TODO implement using Redux?\r\n  constructor (props) {\r\n    super(props);\r\n    // Grid generation\r\n    this.gridHeight = \"gridDimensions\" in props ? props.gridDimensions.height : 20;\r\n    this.gridWidth = \"gridDimensions\" in props ? props.gridDimensions.width : 20;\r\n    let cells = create2DArrayOf(this.gridHeight, this.gridWidth, false);\r\n    this.state = {\r\n      // TODO replace with 1D?\r\n      cells: cells, // A 2D array of bool.\r\n      paused: true\r\n    };\r\n\r\n    this.generationNum = 0;\r\n    this.frequency = \"frequency\" in props ? props.frequency : 2;  // In seconds\r\n    this.nextGenCells = create2DArrayOf(this.gridHeight, this.gridWidth, false);\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div>\r\n        <div className=\"controls\">\r\n          <button onClick={this.togglePaused}>\r\n            {this.state.paused ? \"Unpause\" : \"Pause\"}\r\n          </button>\r\n        </div>\r\n        <Grid\r\n          cells={this.state.cells}\r\n          onCellToggle={this.toggleCell}\r\n        />\r\n      </div>\r\n    );\r\n  }\r\n\r\n\r\n  togglePaused = () => {\r\n    let newPaused;\r\n    if (this.state.paused) {\r\n      this.timer = setInterval(() => this.step(), 1 / this.frequency * 1000);\r\n      newPaused = false;\r\n    } else {\r\n      clearInterval(this.timer);\r\n      newPaused = true;\r\n    }\r\n    this.setState({ ...this.state, paused: newPaused });\r\n  }\r\n\r\n  cellIsAlive(rowI, columnI) {\r\n    if (rowI < 0 || rowI >= this.gridHeight ||\r\n      columnI < 0 || columnI >= this.gridWidth) {\r\n      return false;\r\n    }\r\n    if (this.state.cells[rowI][columnI] === false) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  cellGetNumNeighbors (rowI, columnI) { \r\n    let numNeighbors = 0;\r\n    if (this.cellIsAlive(rowI - 1, columnI - 1)) numNeighbors++;\r\n    if (this.cellIsAlive(rowI - 1, columnI)) numNeighbors++;\r\n    if (this.cellIsAlive(rowI - 1, columnI + 1)) numNeighbors++;\r\n    if (this.cellIsAlive(rowI, columnI - 1)) numNeighbors++;\r\n    if (this.cellIsAlive(rowI, columnI + 1)) numNeighbors++;\r\n    if (this.cellIsAlive(rowI + 1, columnI - 1)) numNeighbors++;\r\n    if (this.cellIsAlive(rowI + 1, columnI)) numNeighbors++;\r\n    if (this.cellIsAlive(rowI + 1, columnI + 1)) numNeighbors++;\r\n    return numNeighbors;\r\n  }\r\n\r\n  step () {\r\n    // TODO calculate the next step before the time has passed\r\n    // TODO only calcualte cells whose neighbours have changed.\r\n\r\n    // Copy the from the old state.\r\n    // You can't just `this.nextGenCells = this.state.cells.slice()`, as this is\r\n    // a shallow copy.\r\n    for (let rowI = 0; rowI < this.nextGenCells.length; rowI++) {\r\n      this.nextGenCells[rowI] = this.state.cells[rowI].slice();\r\n    }\r\n\r\n    // TODO these forEach(..., this) are ugly.\r\n    this.state.cells.forEach((row, rowI) => {\r\n      row.forEach((currCellAlive, columnI) => {\r\n        // Now, the actual game logic\r\n        let numNeighbors = this.cellGetNumNeighbors(rowI, columnI);\r\n        if (\r\n          numNeighbors === 3 ||\r\n          (numNeighbors === 2 && currCellAlive)\r\n        ) {\r\n          this.nextGenCells[rowI][columnI] = true;\r\n        } else {\r\n          this.nextGenCells[rowI][columnI] = false;\r\n        }\r\n      }, this);\r\n    }, this);\r\n    // Exchange the current state and the buffer for the next one.\r\n    let coldCellsGenArr = this.state.cells;\r\n    this.setState({...this.state, cells: this.nextGenCells });\r\n    this.nextGenCells = coldCellsGenArr;\r\n  }\r\n\r\n  toggleCell = (rowI, columnI) => {\r\n    let newCells = this.state.cells;\r\n    newCells[rowI][columnI] = !newCells[rowI][columnI];\r\n    this.setState({...this.state, cells: newCells});\r\n  }\r\n}\r\n\r\nvar mouseDown = false;\r\ndocument.onmousedown = function() {\r\n  mouseDown = true;\r\n};\r\ndocument.onmouseup = function () {\r\n  mouseDown = false;\r\n};\r\n\r\nReactDOM.render(\r\n  <Game gridDimensions={{ height: 30, width: 30 }} />,\r\n  document.getElementById(\"root\")\r\n);"],"sourceRoot":""}